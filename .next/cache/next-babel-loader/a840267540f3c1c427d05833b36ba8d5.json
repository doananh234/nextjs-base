{"ast":null,"code":"import _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _asyncToGenerator from \"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport fetch from 'isomorphic-unfetch';\nimport { getToken } from '../utils/cookies';\n\nvar checkIfErrorOccurs = function checkIfErrorOccurs(res) {\n  return (// console.log('res', res);\n    {\n      code: res.status,\n      res: res\n    }\n  );\n};\n\nvar TIME_OUT = 30000;\n\nvar timeoutPromise = function timeoutPromise(ms, promise) {\n  return new _Promise(function (resolve, reject) {\n    var timeoutId = setTimeout(function () {\n      reject(new Error('Request time out! Please try again.'));\n    }, ms);\n    promise.then(function (res) {\n      clearTimeout(timeoutId);\n      resolve(res);\n    }, function (err) {\n      clearTimeout(timeoutId);\n      reject(err);\n    });\n  });\n};\n\nfunction xFetch(_x, _x2) {\n  return _xFetch.apply(this, arguments);\n}\n\nfunction _xFetch() {\n  _xFetch = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(path, headerOptions) {\n    var ops,\n        normalFetch,\n        res,\n        response,\n        _response,\n        err,\n        _err,\n        _err2,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            ops = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {\n              noParse: false\n            };\n            normalFetch = fetch(path, headerOptions);\n\n            if (!ops.noParse) {\n              _context2.next = 4;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", timeoutPromise(TIME_OUT, normalFetch));\n\n          case 4:\n            _context2.next = 6;\n            return timeoutPromise(TIME_OUT, normalFetch.then(checkIfErrorOccurs));\n\n          case 6:\n            res = _context2.sent;\n\n            if (!(res.code < 300)) {\n              _context2.next = 14;\n              break;\n            }\n\n            if (!(res.code === 204)) {\n              _context2.next = 10;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", {\n              success: true\n            });\n\n          case 10:\n            _context2.next = 12;\n            return res.res.json();\n\n          case 12:\n            response = _context2.sent;\n            return _context2.abrupt(\"return\", response);\n\n          case 14:\n            _context2.prev = 14;\n            _context2.next = 17;\n            return res.res.json();\n\n          case 17:\n            _response = _context2.sent;\n            err = {\n              code: res.code,\n              message: _response.message\n            };\n            throw err;\n\n          case 22:\n            _context2.prev = 22;\n            _context2.t0 = _context2[\"catch\"](14);\n\n            if (!(res.code === 426)) {\n              _context2.next = 29;\n              break;\n            }\n\n            _err = {\n              code: res.code,\n              message: 'We have had some significant upgrades for the app. Please click below to upgrade your app!'\n            };\n            throw _err;\n\n          case 29:\n            _err2 = {\n              code: res.code,\n              message: _context2.t0.message ? _context2.t0.message : 'Something wrong. Please try again.'\n            };\n            throw _err2;\n\n          case 31:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[14, 22]]);\n  }));\n  return _xFetch.apply(this, arguments);\n}\n\nexport default xFetch;\n\nfunction requestWrapper(method) {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(_url) {\n        var _data,\n            _params,\n            context,\n            url,\n            data,\n            params,\n            defaults,\n            token,\n            paramsObj,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _data = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;\n                _params = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n                context = _args.length > 3 ? _args[3] : undefined;\n                url = _url;\n                data = _data;\n                params = _params;\n                url = process.env.API_URL + url;\n\n                if (method === 'GET') {\n                  // is it a GET?\n                  // GET doesn't have data\n                  params = data;\n\n                  if (params !== null) {\n                    url = \"\".concat(url, \"?\").concat(getQueryString(params));\n                  }\n\n                  data = null;\n                } else if (data === Object(data)) {\n                  // (data === Object(data)) === _.isObject(data)\n                  data = _JSON$stringify(data);\n                } // default params for fetch = method + (Content-Type)\n\n\n                defaults = {\n                  method: method,\n                  headers: {\n                    'Content-Type': 'application/json; charset=UTF-8'\n                  }\n                }; // TODO: No need context in case browser\n\n                token = getToken(context);\n\n                if (token) {\n                  defaults.headers.Authorization = \"\".concat(token);\n                }\n\n                if (data) {\n                  defaults.body = data;\n                }\n\n                paramsObj = _objectSpread({}, defaults, {\n                  headers: _objectSpread({}, params, defaults.headers)\n                });\n                return _context.abrupt(\"return\", xFetch(url, paramsObj));\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x3) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n  );\n}\n\nfunction getQueryString(params) {\n  var esc = encodeURIComponent;\n  return _Object$keys(params).map(function (k) {\n    return \"\".concat(esc(k), \"=\").concat(esc(params[k]));\n  }).join('&');\n}\n\nexport var get = requestWrapper('GET');\nexport var post = requestWrapper('POST');\nexport var put = requestWrapper('PUT');\nexport var patch = requestWrapper('PATCH');\nexport var del = requestWrapper('DELETE');","map":null,"metadata":{},"sourceType":"module"}