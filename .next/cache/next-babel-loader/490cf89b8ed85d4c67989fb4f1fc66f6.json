{"ast":null,"code":"import _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport fetch from 'isomorphic-unfetch';\nimport { getToken } from '../utils/cookies';\n\nconst checkIfErrorOccurs = res => ( // console.log('res', res);\n{\n  code: res.status,\n  res\n});\n\nconst TIME_OUT = 30000;\n\nconst timeoutPromise = function timeoutPromise(ms, promise) {\n  return new _Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error('Request time out! Please try again.'));\n    }, ms);\n    promise.then(res => {\n      clearTimeout(timeoutId);\n      resolve(res);\n    }, err => {\n      clearTimeout(timeoutId);\n      reject(err);\n    });\n  });\n};\n\nasync function xFetch(path, headerOptions, ops = {\n  noParse: false\n}) {\n  const normalFetch = fetch(path, headerOptions);\n\n  if (ops.noParse) {\n    return timeoutPromise(TIME_OUT, normalFetch);\n  }\n\n  const res = await timeoutPromise(TIME_OUT, normalFetch.then(checkIfErrorOccurs));\n\n  if (res.code < 300) {\n    if (res.code === 204) {\n      return {\n        success: true\n      };\n    }\n\n    const response = await res.res.json();\n    return response;\n  }\n\n  try {\n    const response = await res.res.json();\n    const err = {\n      code: res.code,\n      message: response.message\n    };\n    throw err;\n  } catch (e) {\n    if (res.code === 426) {\n      const err = {\n        code: res.code,\n        message: 'We have had some significant upgrades for the app. Please click below to upgrade your app!'\n      };\n      throw err;\n    } else {\n      const err = {\n        code: res.code,\n        message: e.message ? e.message : 'Something wrong. Please try again.'\n      };\n      throw err;\n    }\n  }\n}\n\nexport default xFetch;\n\nfunction getQueryString(params) {\n  const esc = encodeURIComponent;\n  return _Object$keys(params).map(k => `${esc(k)}=${esc(params[k])}`).join('&');\n}\n\nfunction requestWrapper(method) {\n  return async (_url, _data = null, _params = {}, context) => {\n    let url = _url;\n    let data = _data;\n    let params = _params;\n    url = process.env.API_URL + url;\n\n    if (method === 'GET') {\n      // is it a GET?\n      // GET doesn't have data\n      params = data;\n\n      if (params !== null) {\n        url = `${url}?${getQueryString(params)}`;\n      }\n\n      data = null;\n    } else if (data === Object(data)) {\n      // (data === Object(data)) === _.isObject(data)\n      data = _JSON$stringify(data);\n    } // default params for fetch = method + (Content-Type)\n\n\n    const defaults = {\n      method,\n      headers: {\n        'Content-Type': 'application/json; charset=UTF-8'\n      }\n    }; // TODO: No need context in case browser\n\n    const token = getToken(context);\n\n    if (token) {\n      defaults.headers.Authorization = `${token}`;\n    }\n\n    if (data) {\n      defaults.body = data;\n    }\n\n    const paramsObj = _objectSpread({}, defaults, {\n      headers: _objectSpread({}, params, defaults.headers)\n    });\n\n    return xFetch(url, paramsObj);\n  };\n}\n\nexport const get = requestWrapper('GET');\nexport const post = requestWrapper('POST');\nexport const put = requestWrapper('PUT');\nexport const patch = requestWrapper('PATCH');\nexport const del = requestWrapper('DELETE');","map":{"version":3,"sources":["/Users/apple/Work/myproject/base/base-nextjs/api/utils.js"],"names":["fetch","getToken","checkIfErrorOccurs","res","code","status","TIME_OUT","timeoutPromise","ms","promise","resolve","reject","timeoutId","setTimeout","Error","then","clearTimeout","err","xFetch","path","headerOptions","ops","noParse","normalFetch","success","response","json","message","e","getQueryString","params","esc","encodeURIComponent","map","k","join","requestWrapper","method","_url","_data","_params","context","url","data","process","env","API_URL","Object","defaults","headers","token","Authorization","body","paramsObj","get","post","put","patch","del"],"mappings":"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","sourcesContent":["import fetch from 'isomorphic-unfetch';\nimport { getToken } from '../utils/cookies';\n\nconst checkIfErrorOccurs = res =>\n  // console.log('res', res);\n  ({\n    code: res.status,\n    res,\n  });\nconst TIME_OUT = 30000;\n\nconst timeoutPromise = function timeoutPromise(ms, promise) {\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error('Request time out! Please try again.'));\n    }, ms);\n    promise.then(\n      res => {\n        clearTimeout(timeoutId);\n        resolve(res);\n      },\n      err => {\n        clearTimeout(timeoutId);\n        reject(err);\n      }\n    );\n  });\n};\n\nasync function xFetch(path, headerOptions, ops = { noParse: false }) {\n  const normalFetch = fetch(path, headerOptions);\n  if (ops.noParse) {\n    return timeoutPromise(TIME_OUT, normalFetch);\n  }\n  const res = await timeoutPromise(\n    TIME_OUT,\n    normalFetch.then(checkIfErrorOccurs)\n  );\n\n  if (res.code < 300) {\n    if (res.code === 204) {\n      return { success: true };\n    }\n    const response = await res.res.json();\n    return response;\n  }\n  try {\n    const response = await res.res.json();\n    const err = {\n      code: res.code,\n      message: response.message,\n    };\n    throw err;\n  } catch (e) {\n    if (res.code === 426) {\n      const err = {\n        code: res.code,\n        message:\n          'We have had some significant upgrades for the app. Please click below to upgrade your app!',\n      };\n      throw err;\n    } else {\n      const err = {\n        code: res.code,\n        message: e.message ? e.message : 'Something wrong. Please try again.',\n      };\n      throw err;\n    }\n  }\n}\n\nexport default xFetch;\n\nfunction getQueryString(params) {\n  const esc = encodeURIComponent;\n  return Object.keys(params)\n    .map(k => `${esc(k)}=${esc(params[k])}`)\n    .join('&');\n}\n\nfunction requestWrapper(method) {\n  return async (_url, _data = null, _params = {}, context) => {\n    let url = _url;\n    let data = _data;\n    let params = _params;\n    url = process.env.API_URL + url;\n    if (method === 'GET') {\n      // is it a GET?\n      // GET doesn't have data\n      params = data;\n      if (params !== null) {\n        url = `${url}?${getQueryString(params)}`;\n      }\n      data = null;\n    } else if (data === Object(data)) {\n      // (data === Object(data)) === _.isObject(data)\n      data = JSON.stringify(data);\n    }\n\n    // default params for fetch = method + (Content-Type)\n    const defaults = {\n      method,\n      headers: {\n        'Content-Type': 'application/json; charset=UTF-8',\n      },\n    };\n\n    // TODO: No need context in case browser\n    const token = getToken(context);\n\n    if (token) {\n      defaults.headers.Authorization = `${token}`;\n    }\n\n    if (data) {\n      defaults.body = data;\n    }\n\n    const paramsObj = {\n      ...defaults,\n      headers: { ...params, ...defaults.headers },\n    };\n    return xFetch(url, paramsObj);\n  };\n}\n\nexport const get = requestWrapper('GET');\nexport const post = requestWrapper('POST');\nexport const put = requestWrapper('PUT');\nexport const patch = requestWrapper('PATCH');\nexport const del = requestWrapper('DELETE');\n"]},"metadata":{},"sourceType":"module"}