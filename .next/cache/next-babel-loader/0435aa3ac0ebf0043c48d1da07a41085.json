{"ast":null,"code":"import _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport fetch from 'isomorphic-unfetch';\nimport { getToken } from '../utils/cookies';\n\nconst checkIfErrorOccurs = res => ( // console.log('res', res);\n{\n  code: res.status,\n  res\n});\n\nconst TIME_OUT = 30000;\n\nconst timeoutPromise = function timeoutPromise(ms, promise) {\n  return new _Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error('Request time out! Please try again.'));\n    }, ms);\n    promise.then(res => {\n      clearTimeout(timeoutId);\n      resolve(res);\n    }, err => {\n      clearTimeout(timeoutId);\n      reject(err);\n    });\n  });\n};\n\nasync function xFetch(path, headerOptions, ops = {\n  noParse: false\n}) {\n  const normalFetch = fetch(path, headerOptions);\n\n  if (ops.noParse) {\n    return timeoutPromise(TIME_OUT, normalFetch);\n  }\n\n  const res = await timeoutPromise(TIME_OUT, normalFetch.then(checkIfErrorOccurs));\n\n  if (res.code < 300) {\n    if (res.code === 204) {\n      return {\n        success: true\n      };\n    }\n\n    const response = await res.res.json();\n    return response;\n  }\n\n  try {\n    const response = await res.res.json();\n    const err = {\n      code: res.code,\n      message: response.message\n    };\n    throw err;\n  } catch (e) {\n    if (res.code === 426) {\n      const err = {\n        code: res.code,\n        message: 'We have had some significant upgrades for the app. Please click below to upgrade your app!'\n      };\n      throw err;\n    } else {\n      const err = {\n        code: res.code,\n        message: e.message ? e.message : 'Something wrong. Please try again.'\n      };\n      throw err;\n    }\n  }\n}\n\nexport default xFetch;\n\nfunction requestWrapper(method) {\n  return async (_url, _data = null, _params = {}, context) => {\n    let url = _url;\n    let data = _data;\n    let params = _params;\n    url = process.env.API_URL + url;\n\n    if (method === 'GET') {\n      // is it a GET?\n      // GET doesn't have data\n      params = data;\n\n      if (params !== null) {\n        url = `${url}?${getQueryString(params)}`;\n      }\n\n      data = null;\n    } else if (data === Object(data)) {\n      // (data === Object(data)) === _.isObject(data)\n      data = _JSON$stringify(data);\n    } // default params for fetch = method + (Content-Type)\n\n\n    const defaults = {\n      method,\n      headers: {\n        'Content-Type': 'application/json; charset=UTF-8'\n      }\n    }; // TODO: No need context in case browser\n\n    const token = getToken(context);\n\n    if (token) {\n      defaults.headers.Authorization = `${token}`;\n    }\n\n    if (data) {\n      defaults.body = data;\n    }\n\n    const paramsObj = _objectSpread({}, defaults, {\n      headers: _objectSpread({}, params, defaults.headers)\n    });\n\n    return xFetch(url, paramsObj);\n  };\n}\n\nfunction getQueryString(params) {\n  const esc = encodeURIComponent;\n  return _Object$keys(params).map(k => `${esc(k)}=${esc(params[k])}`).join('&');\n}\n\nexport const get = requestWrapper('GET');\nexport const post = requestWrapper('POST');\nexport const put = requestWrapper('PUT');\nexport const patch = requestWrapper('PATCH');\nexport const del = requestWrapper('DELETE');","map":null,"metadata":{},"sourceType":"module"}